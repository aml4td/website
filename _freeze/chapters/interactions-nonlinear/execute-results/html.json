{
  "hash": "77d7bf656d8179c65c45d532e8a7b373",
  "result": {
    "engine": "knitr",
    "markdown": "---\nknitr:\n  opts_chunk:\n    cache.path: \"../_cache/interactions-nonlinear/\"\n---\n\n\n# Interactions and Nonlinear Features {#sec-interactions-nonlinear}\n\n\n\n\n\n\n\nWe saw in previous chapters that preprocessing is necessary because models can be sensitive to specific predictor characteristics.  For instance, some models:\n\n- are sensitive to highly correlated predictors.\n- cannot consume qualitative predictors as non-numeric data.\n- cannot be built when predictors have no or near-zero variability.\n\nPreprocessing methods address aspects of the predictors that place them in a form so that models can be built.  This is _what the model needs_ to function.\n\nWhile preprocessing techniques allow models to be built, they do not necessarily transform them in ways that help the model to identify predictive relationships with the outcome.  This is the fundamental concept of **feature engineering** which addresses the question:  what can we do to make it easier for the model to understand and predict the outcome.\n\n In this chapter we will discuss techniques that address this question.   For example, if the relationship between a predictor is nonlinear, how can we represent that predictor so that the relationship can be modeled?  Or if two predictors work in conjunction with each other, then how can this information be engineered for a model?  While feature engineering is not necessary for models to be built, it contains a crucial set of tools for improving model performance.\n\nLet’s look at a simple example. Occasionally, predictor pairs work better in unison rather than as main effects. For example, consider the data in @fig-two-class-corr(a), where two predictors are: \n\n- strictly positive,\n- significantly right-skewed, and\n- highly correlated. \n\nIn the predictors' original form, there is a significant overlap between the two classes of samples.  However, when the ratio of the predictors is used, the newly derived predictor better discriminates between classes (shown in @fig-two-class-corr(b)). While not a general rule, the three data characteristics above suggest that the modeler attempts to form ratios from two or more predictors ^[Alternatively, PCA after skewness-correcting transformations may be another good option.].\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Panel (a): two highly correlated, right-skewed predictors with two classes. Panel (b): sepration of classes using $log(A/B)$.](../figures/fig-two-class-corr-1.light.svg){#fig-two-class-corr fig-align='center' fig-alt='Panel (a): two highly correlated, right-skewed predictors with two classes. Panel (b): sepration of classes using $log(A/B)$.' width=80%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nIt is essential to understand that these _data_ require transformation. We can put the original predictors into a model as-is. The model won’t produce an error but won’t have good predictive performance. We can induce a separation of the classes when a joint feature is used. \n\nThis aspect of feature engineering depends on the data set so it is difficult to enumerate all possible techniques. In this chapter, we’ll describe a few commonly used methods: splines, interactions, and discretization (a.k.a. binning). \n\n## Interactions {#sec-interactions}\n\nWhen building models for prediction, the majority of variation in the outcome is generally explained by the cumulative effect of the important individual predictors.  For many problems, additional variation in the response can be explained by the effect of two or more predictors working in conjunction with each other.  \n\nThe healthcare industry has long understood the concept of interactions among drugs for treating specific diseases [@singh2017suppressive, @mokhtari2017combination, and @altorki2021neoadjuvant].  As an example of an interaction, consider treatment for the disease non-small cell lung cancer (NSCLC).  In a recent study, patients with an advanced stage of NSCLC with an EGFR mutation were given either osimertinib alone or osimertinib in combination with traditional chemotherapy [@NEJMoa2306434].   Patients taking the combination treatment had a significantly longer progression-free survival time than patients taking osmertinib alone.  Hence, the interaction of the treatments is more effective than the single treatment.  To summarize, two (or more) predictors interact if their combined impact is different (less or greater) than what would be expected from the added impact of each predictor alone.\n\nWe’ve already encountered an example of an interaction in @sec-eda-whole-game where the relationship between delivery time and the time of order differed across days of the week. This trend is reproduced in @fig-delivery-no-interact(a). The telltale sign of the interaction is that the trendlines are not parallel with one another; they have different rates of increase and cross. \n\nHow would this plot change if there was no interaction between the order time and day? To illustrate, we estimated trendlines in a way that coerced the nonlinear trend for order time to be the same.  @fig-delivery-no-interact(b) shows the results: parallel lines for each day of the week. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Delivery times versus the time of the order, colored by the day of the week. (a) A duplicate of a panel from @fig-delivery-predictors. (b) The same data with trendlines where the underlying model did _not_ allow an interaction between the delivery day and hour.](../figures/fig-delivery-no-interact-1.light.svg){#fig-delivery-no-interact fig-align='center' width=85%}\n:::\n:::\n\n\nThis example demonstrates an interaction between a numeric predictor (hour of order) and a categorical predictor (day of the week). Interactions can also occur between two (or more) numeric or categorical predictors. Using the delivery data, let’s examine potential interactions solely between categorical predictor columns. \n\nFor regression problems, one visualization technique is to compute the means (or medians) of the outcome for all combinations of variables and then plot these means in a manner similar to the previous figure. Let’s look at the 27 predictors columns for whether a specific item was included in the order. The original data is a count, but the data are mostly zero or one. We’ll look at two variables at a time and plot the four combinations of whether the item was ordered at all (versus not at all). @fig-delivery-items shows two potential sets of interactions. The x-axis indicates whether Item 1 was in the order or not. The y-axis is the mean delivery time with 90% confidence intervals^[These were computed using the bootstrap, as in @sec-eda-whole-game.].\n\nThe left panel shows the joint effect of items 1 and 9. The lines connecting the means are parallel. This indicates that each of these two predictors affects the outcome independently of one another. Specifically, the incremental change in delivery time is the same when item 9 is or is not included with item 1.  The right panel has means for items 1 and 10. The mean delivery times are very similar when neither is contained in the order. Also, when only one of the two items is in the order, the average time is similarly small. However, when both are included, the delivery time becomes much larger.  This means that you cannot consider the effect or either item 1 or 10 alone; their effect on the outcome occurs jointly. \n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Interaction examples with two categorical predictors. Items 1 and 9 (left panel) do not interaction, while items 1 and 10 appear to have a strong  interaction (right panel).](../figures/fig-delivery-items-1.light.svg){#fig-delivery-items fig-align='center' width=70%}\n:::\n:::\n\n\nAs a third example, interactions may occur between continuous predictors. It can be difficult to discover the interaction via visualization for two numeric predictors without converting one of the predictors to categorical bins. To illustrate the _concept_ of an interaction between two numeric predictors, $x_1$ and $x_2$, let’s use a simple linear equation:\n\n$$ \ny = \\beta_0 + \\beta_{1}x_1 + \\beta_{2}x_2 + \\beta_{3}x_{1}x_{2} + \\epsilon\n$$ {#eq-two-way-int}\n\nThe $\\beta$ coefficients represent the overall average response ($\\beta_0$), the average rate of change for each individual predictor ($\\beta_1$ and $\\beta_2$), and the incremental rate of change due to the combined effect of $x_1$ and $x_2$ ($\\beta_3$) that goes beyond what $x_1$ and $x_2$ can explain alone.  The parameters for this equation can be estimated using a technique such as ordinary least squares (REF).  The sign and magnitude of $\\beta_3$ indicate how and the extent to which the two predictors interact:   \n\n - When $\\beta_3$ is positive, the interaction is _synergistic_ since the response increases beyond the effect of either predictor alone.  \n - Alternatively, when $\\beta_3$ is negative, the interaction is _antagonistic_ since the response decreases beyond the effect of either predictor alone.  \n - A third scenario is when $\\beta_3$ is essentially zero.  In this case, there is no interaction between the predictors and the relationship between the predictors is _additive_. \n - Finally, for some data sets, we may find that neither predictor is important individually (i.e., $\\beta_1$ and $\\beta_2$ are zero).  However, the coefficient on the interaction term is not zero.  Because this case occurs very infrequently, it is called _atypical_. \n \nTo understand this better, @fig-interaction-contours shows a contour plot of a predicted linear regression model with various combinations of the model slope parameters. The two predictors are centered at zero with values ranging within $x_j \\pm 4.0$). The default setting shows a moderate synergistic interaction effect since all of the $\\beta_j = 1.0$). In the plot, darker values indicate smaller predicted values.   \n\n::: {#fig-interaction-contours}\n\n::: {.figure-content}\n\n```{shinylive-r}\n#| label: fig-interaction-contours\n#| viewerHeight: 600\n#| standalone: true\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(bslib)\nlibrary(viridis)\n\nsource(\"https://raw.githubusercontent.com/aml4td/website/main/R/shiny-setup.R\")\nsource(\"https://raw.githubusercontent.com/aml4td/website/dark-mode/R/shiny-interaction-contours.R\")\n\napp\n```\n:::\n\nPrediction contours for a linear regression model with @eq-two-way-int with $\\beta_0 = 0$. Darker values indicate smaller predictions. \n\n:::\n\nInteraction effects between predictors are sometimes confused with correlation between predictors. They are not the same thing. Interactions are defined by their relationship to the outcome while between-predictors correlations are unrelated to it. An interaction could occur independent of the amount of correlation between predictors. \n\n### How Likely Are Interactions? {#sec-interactions-princples} \n\nWithin the context of statistical experimental design, @hamada1992analysis discuss some probabilistic aspects of predictor importance. The effect sparsity principle is that there are often few predictors that are relevant for predicting the outcome. Similarly, the effect hierarchy principle states that “main effects” (i.e. a feature involving only predictor) are more likely to occur than interactions. Also, as more predictors are involved in the interaction, the less likely they become. Finally, the heredity principle conjectures that if an interaction is important, it is very likely that the corresponding main effects are likely too. @chipman1996bayesian further expands this principle. \n\nThe original context of these principles was envisioned for screening large numbers of predictors in experimental designs; they are still very relevant for the analysis of tabular data. \n\n### Detecting Interactions {#sec-interactions-detection} \n\nAn ideal scenario would be that we would know which predictors interact before modeling the data.  If this would be the case, then these terms could be included in a model.  This would be ideal because the model could more easily find the relationship with the response, thus leading to better predictive performance.  Unfortunately, knowledge of which predictors interact is usually not available prior to initiating the modeling process.  \n\nIf meaningful interactions are unknown before modeling, can models still discover and utilize these potentially important features? Recent studies using various advanced modeling techniques have shown that some methods can inherently detect interactions. For example, tree-based models [@elith2008working], random forests [@garcia2009evaluating], boosted trees [@lampa2014identification], and support vector machines [@chen2008support] are effective at uncovering them. \n\nIf modern modeling techniques can naturally find and utilize interactions, then why is it necessary to spend any time uncovering these relationships?  The first reason is to improve interpretability.  Recall the trade-off between prediction and interpretation that was discussed in Section TODO.  More complex models are less interpretable and generally more predictive, while simpler models are more interpretable and less predictive.   Therefore, if we know which interaction(s) are important, we can include these in a simpler model to enable a better interpretation.  A second reason to spend time uncovering interactions is to help improve the predictive performance of models.  \n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n \nWhat should we do if we have a candidate set of interactions?  If we are using a more formal statistical model, such as linear or logistic regression, the traditional tool for evaluating whether additional model terms in a set of nested models are worth including is the conventional analysis of variance (ANOVA). This uses the statistical likelihood value as the objective function, which is equivalent to comparing the RMSE values between models for linear regression ^[It so happens that the Gaussian likelihood function is equivalent to the sums of squared errors (SSE). That, in turn, is equivalent to the RMSE. That simplification does not automatically occur for other probability distributions.]. The error reduction and how many additional terms are responsible for the improvement are computed. Using these results and some probability assumptions about the data, we can formally test the null hypothesis that the additional parameters all have coefficient values of zero. \n\nLooking at the delivery data, our model in @sec-model-development-whole-game included a single set of interactions (e.g., hour-by-day). What if we included one more interaction: item 1 $\\times$ item 10? @tbl-interaction-anova shows the ANOVA results. The RMSE _computed on the training set_ is listed in the first and second columns. The reduction by including this additional model term is 0.18 (decimal minutes). Assuming normality of the model residuals, the p-value for this test is exceedingly small. This indicates that there is no evidence that this parameter is truly zero. In other words, there is strong evidence that the inclusion of the interaction helps explain the response.  This statistical difference may not make much of a practical difference. However, machine learning models often behave like \"a game of inches\" where every small improvement adds up to an overall improvement that matters. \n\n\n::: {#tbl-interaction-anova .cell layout-align=\"center\" tbl-cap='ANOVA table and validation set statistics for three models with different interaction sets.'}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"hhmpqowhwm\" style=\"padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;\">\n<style>#hhmpqowhwm table {\n  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n#hhmpqowhwm thead, #hhmpqowhwm tbody, #hhmpqowhwm tfoot, #hhmpqowhwm tr, #hhmpqowhwm td, #hhmpqowhwm th {\n  border-style: none;\n}\n\n#hhmpqowhwm p {\n  margin: 0;\n  padding: 0;\n}\n\n#hhmpqowhwm .gt_table {\n  display: table;\n  border-collapse: collapse;\n  line-height: normal;\n  margin-left: auto;\n  margin-right: auto;\n  color: #333333;\n  font-size: 16px;\n  font-weight: normal;\n  font-style: normal;\n  background-color: #FFFFFF;\n  width: auto;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #A8A8A8;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #A8A8A8;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_caption {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n\n#hhmpqowhwm .gt_title {\n  color: #333333;\n  font-size: 125%;\n  font-weight: initial;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-color: #FFFFFF;\n  border-bottom-width: 0;\n}\n\n#hhmpqowhwm .gt_subtitle {\n  color: #333333;\n  font-size: 85%;\n  font-weight: initial;\n  padding-top: 3px;\n  padding-bottom: 5px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-color: #FFFFFF;\n  border-top-width: 0;\n}\n\n#hhmpqowhwm .gt_heading {\n  background-color: #FFFFFF;\n  text-align: center;\n  border-bottom-color: #FFFFFF;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_bottom_border {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_col_headings {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_col_heading {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 6px;\n  padding-left: 5px;\n  padding-right: 5px;\n  overflow-x: hidden;\n}\n\n#hhmpqowhwm .gt_column_spanner_outer {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: normal;\n  text-transform: inherit;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: 4px;\n  padding-right: 4px;\n}\n\n#hhmpqowhwm .gt_column_spanner_outer:first-child {\n  padding-left: 0;\n}\n\n#hhmpqowhwm .gt_column_spanner_outer:last-child {\n  padding-right: 0;\n}\n\n#hhmpqowhwm .gt_column_spanner {\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: bottom;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  overflow-x: hidden;\n  display: inline-block;\n  width: 100%;\n}\n\n#hhmpqowhwm .gt_spanner_row {\n  border-bottom-style: hidden;\n}\n\n#hhmpqowhwm .gt_group_heading {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  text-align: left;\n}\n\n#hhmpqowhwm .gt_empty_group_heading {\n  padding: 0.5px;\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  vertical-align: middle;\n}\n\n#hhmpqowhwm .gt_from_md > :first-child {\n  margin-top: 0;\n}\n\n#hhmpqowhwm .gt_from_md > :last-child {\n  margin-bottom: 0;\n}\n\n#hhmpqowhwm .gt_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  margin: 10px;\n  border-top-style: solid;\n  border-top-width: 1px;\n  border-top-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 1px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 1px;\n  border-right-color: #D3D3D3;\n  vertical-align: middle;\n  overflow-x: hidden;\n}\n\n#hhmpqowhwm .gt_stub {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hhmpqowhwm .gt_stub_row_group {\n  color: #333333;\n  background-color: #FFFFFF;\n  font-size: 100%;\n  font-weight: initial;\n  text-transform: inherit;\n  border-right-style: solid;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n  padding-left: 5px;\n  padding-right: 5px;\n  vertical-align: top;\n}\n\n#hhmpqowhwm .gt_row_group_first td {\n  border-top-width: 2px;\n}\n\n#hhmpqowhwm .gt_row_group_first th {\n  border-top-width: 2px;\n}\n\n#hhmpqowhwm .gt_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hhmpqowhwm .gt_first_summary_row {\n  border-top-style: solid;\n  border-top-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_first_summary_row.thick {\n  border-top-width: 2px;\n}\n\n#hhmpqowhwm .gt_last_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_grand_summary_row {\n  color: #333333;\n  background-color: #FFFFFF;\n  text-transform: inherit;\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hhmpqowhwm .gt_first_grand_summary_row {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-top-style: double;\n  border-top-width: 6px;\n  border-top-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_last_grand_summary_row_top {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  padding-left: 5px;\n  padding-right: 5px;\n  border-bottom-style: double;\n  border-bottom-width: 6px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_striped {\n  background-color: rgba(128, 128, 128, 0.05);\n}\n\n#hhmpqowhwm .gt_table_body {\n  border-top-style: solid;\n  border-top-width: 2px;\n  border-top-color: #D3D3D3;\n  border-bottom-style: solid;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_footnotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_footnote {\n  margin: 0px;\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hhmpqowhwm .gt_sourcenotes {\n  color: #333333;\n  background-color: #FFFFFF;\n  border-bottom-style: none;\n  border-bottom-width: 2px;\n  border-bottom-color: #D3D3D3;\n  border-left-style: none;\n  border-left-width: 2px;\n  border-left-color: #D3D3D3;\n  border-right-style: none;\n  border-right-width: 2px;\n  border-right-color: #D3D3D3;\n}\n\n#hhmpqowhwm .gt_sourcenote {\n  font-size: 90%;\n  padding-top: 4px;\n  padding-bottom: 4px;\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n#hhmpqowhwm .gt_left {\n  text-align: left;\n}\n\n#hhmpqowhwm .gt_center {\n  text-align: center;\n}\n\n#hhmpqowhwm .gt_right {\n  text-align: right;\n  font-variant-numeric: tabular-nums;\n}\n\n#hhmpqowhwm .gt_font_normal {\n  font-weight: normal;\n}\n\n#hhmpqowhwm .gt_font_bold {\n  font-weight: bold;\n}\n\n#hhmpqowhwm .gt_font_italic {\n  font-style: italic;\n}\n\n#hhmpqowhwm .gt_super {\n  font-size: 65%;\n}\n\n#hhmpqowhwm .gt_footnote_marks {\n  font-size: 75%;\n  vertical-align: 0.4em;\n  position: initial;\n}\n\n#hhmpqowhwm .gt_asterisk {\n  font-size: 100%;\n  vertical-align: 0;\n}\n\n#hhmpqowhwm .gt_indent_1 {\n  text-indent: 5px;\n}\n\n#hhmpqowhwm .gt_indent_2 {\n  text-indent: 10px;\n}\n\n#hhmpqowhwm .gt_indent_3 {\n  text-indent: 15px;\n}\n\n#hhmpqowhwm .gt_indent_4 {\n  text-indent: 20px;\n}\n\n#hhmpqowhwm .gt_indent_5 {\n  text-indent: 25px;\n}\n</style>\n<table class=\"gt_table\" style=\"table-layout: fixed;\" data-quarto-disable-processing=\"false\" data-quarto-bootstrap=\"false\">\n  <colgroup>\n    <col style=\"width:100px;\"/>\n    <col/>\n    <col/>\n    <col/>\n    <col style=\"width:80px;\"/>\n    <col/>\n    <col/>\n  </colgroup>\n  <thead>\n    <tr class=\"gt_col_headings gt_spanner_row\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"2\" colspan=\"1\" style=\"border-top-width: 1.8px; border-top-style: solid; border-top-color: #000000; border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\" scope=\"col\" id=\"Interactions\">Interactions</th>\n      <th class=\"gt_center gt_columns_top_border gt_column_spanner_outer\" rowspan=\"1\" colspan=\"2\" scope=\"colgroup\" id=\"Training Set RMSE\">\n        <span class=\"gt_column_spanner\">Training Set RMSE</span>\n      </th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"2\" colspan=\"1\" style=\"border-top-width: 1.8px; border-top-style: solid; border-top-color: #000000; border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\" scope=\"col\" id=\"Deg. Free.\">Deg. Free.</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"2\" colspan=\"1\" style=\"border-top-width: 1.8px; border-top-style: solid; border-top-color: #000000; border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\" scope=\"col\" id=\"p-Value\">p-Value</th>\n      <th class=\"gt_center gt_columns_top_border gt_column_spanner_outer\" rowspan=\"1\" colspan=\"2\" scope=\"colgroup\" id=\"Validation Set\">\n        <span class=\"gt_column_spanner\">Validation Set</span>\n      </th>\n    </tr>\n    <tr class=\"gt_col_headings\">\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"border-top-width: 1.8px; border-top-style: solid; border-top-color: #000000; border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\" scope=\"col\" id=\"Decimal\">Decimal</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_left\" rowspan=\"1\" colspan=\"1\" style=\"border-top-width: 1.8px; border-top-style: solid; border-top-color: #000000; border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\" scope=\"col\" id=\"Time\">Time</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"border-top-width: 1.8px; border-top-style: solid; border-top-color: #000000; border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\" scope=\"col\" id=\"RMSE\">RMSE</th>\n      <th class=\"gt_col_heading gt_columns_bottom_border gt_right\" rowspan=\"1\" colspan=\"1\" style=\"border-top-width: 1.8px; border-top-style: solid; border-top-color: #000000; border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\" scope=\"col\" id=\"MAE\">MAE</th>\n    </tr>\n  </thead>\n  <tbody class=\"gt_table_body\">\n    <tr><td headers=\"Interactions\" class=\"gt_row gt_left\">Hour x Day</td>\n<td headers=\"Decimal\" class=\"gt_row gt_right\">2.30</td>\n<td headers=\"Time\" class=\"gt_row gt_left\">(2m, 17s)</td>\n<td headers=\"Deg. Free.\" class=\"gt_row gt_right\">5,890</td>\n<td headers=\"p-Value\" class=\"gt_row gt_left\"><div data-qmd=\"\"><div class='gt_from_md'></div></div></td>\n<td headers=\"RMSE\" class=\"gt_row gt_right\">2.29</td>\n<td headers=\"MAE\" class=\"gt_row gt_right\">1.61</td></tr>\n    <tr><td headers=\"Interactions\" class=\"gt_row gt_left\">Add One Item Interaction</td>\n<td headers=\"Decimal\" class=\"gt_row gt_right\">2.12</td>\n<td headers=\"Time\" class=\"gt_row gt_left\">(2m, 6s)</td>\n<td headers=\"Deg. Free.\" class=\"gt_row gt_right\">5,889</td>\n<td headers=\"p-Value\" class=\"gt_row gt_left\"><div data-qmd=\"10<sup>-219.8</sup>\"><div class='gt_from_md'><p>10<sup>-219.8</sup></p>\n</div></div></td>\n<td headers=\"RMSE\" class=\"gt_row gt_right\">2.10</td>\n<td headers=\"MAE\" class=\"gt_row gt_right\">1.56</td></tr>\n    <tr><td headers=\"Interactions\" class=\"gt_row gt_left\" style=\"border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\">Add All Item Interactions</td>\n<td headers=\"Decimal\" class=\"gt_row gt_right\" style=\"border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\">2.06</td>\n<td headers=\"Time\" class=\"gt_row gt_left\" style=\"border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\">(2m, 3s)</td>\n<td headers=\"Deg. Free.\" class=\"gt_row gt_right\" style=\"border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\">5,539</td>\n<td headers=\"p-Value\" class=\"gt_row gt_left\" style=\"border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\"><div data-qmd=\"10<sup>-18.4</sup>\"><div class='gt_from_md'><p>10<sup>-18.4</sup></p>\n</div></div></td>\n<td headers=\"RMSE\" class=\"gt_row gt_right\" style=\"border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\">2.13</td>\n<td headers=\"MAE\" class=\"gt_row gt_right\" style=\"border-bottom-width: 1.8px; border-bottom-style: solid; border-bottom-color: #000000;\">1.60</td></tr>\n  </tbody>\n  \n  \n</table>\n</div>\n```\n\n:::\n:::\n\n\nWhat about the other two-way interactions between the other item predictors? Since the training set is fairly large (compared to the current number of model parameters), it is feasible to include the remaining 350 pairwise interactions and use the ANOVA method to validate this choice. These results are contained in the third row of @tbl-interaction-anova where the RMSE dropped further by 0.05 minutes. The p-value is also very small, indicating that there is no evidence that _all_ of the  350 parameter estimates are zero. More extensive testing would be required to determine which actually are zero. This can be tedious and a potentially dangerous \"fishing expedition\" that could result in serious bias creeping into the modeling process. \n\nOne problem with the ANOVA method is that it calculates the model error using the training set, which we know may not indicate what would occur with previously unseen data. In fact, it is well known that, for linear regression via ordinary least squares estimation, it is impossible for the training set error to ever increase when adding new model terms. Therefore, was the drop in RMSE when all interactions were included due to this fact?  Or was it due to other important interactions that were included?  To understand this we can turn to the validation set to provide confirmation.  You can see this in @tbl-interaction-anova where the validation set RMSE and MAE values are included. Note that, when the large set of interactions were added, these metrics both _increase_ in the validation set, a result contrary to what the ANOVA results tell us.  \n\nThe observed and predicted visualizations for each model in @tbl-interaction-anova are shown in @fig-lin-reg-interactions. Adding the additional interaction yielded a slight numerical improvement. However, the visualization in the middle panel shows fewer very large residuals. The figure also shows the model results that include the full set of  351 two-way interactions; this panel shows no significant reduction in large residuals, further casting doubt on using the entire set. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Validation set predicted vs. observed delivery times for linear regression models with and without additional interactions.](../figures/fig-lin-reg-interactions-1.light.svg){#fig-lin-reg-interactions fig-align='center' width=90%}\n:::\n:::\n\n\nSo far, we have used visualizations to unearth potential interactions. This can be an effective strategy when the number of potential interactions is large, but the visual nature of this process is subjective. There are some specialized quantitative tools for identifying interactions. For example, @lim2015learning used regularized generalized linear models (sections TODO) to estimate all possible two-way interactions and use a penalization method to determine which should be retained. @miller1984selection and @fes ([Section 7.4.3](https://bookdown.org/max/FES/approaches-when-complete-enumeration-is-practically-impossible.html#the-feasible-solution-algorithm)) describe the feasible solution algorithm, an iterative search method for interaction discovery. Another, which we will now describe in more detail, is Friedman's H-statistic [@friedman2008predictive]. \n\nWe can estimate the joint effect of a set of predictors on the outcome as well as the effect of individual predictors. If we thought that only main effects and two-factor interactions were possible, we could factor out the individual effects from the joint effect. The leftover predictive ability would then be due to interactions. Consider the linear model in @eq-two-way-int. The joint effect would include all possible model terms associated with a predictor. We can also create main effects too: \n\n\\begin{align}\nf(x_1, x_2) &= \\beta_{1}x_1 + \\beta_{2}x_2 + \\beta_{3}x_{1}x_{2} \\notag \\\\\nf(x_1) &= \\beta_{1}x_1  \\notag \\\\\nf(x_2) &= \\beta_{2}x_2 \\notag \n\\end{align}\n\nTo isolate the potential interaction effect: \n\n$$\nf(x_1\\times x_2) = f(x_1, x_2) - f(x_1) - f(x_2) = \\beta_{3}x_{1}x_{2}\n$$ {#eq-int-isolate}\n\nThis shows that, for this situation, we can isolate the effect of an interaction by removing any other systematic effects in the data^[This approach works because the model in @eq-two-way-int is _capable_ of estimating the interaction. There are many models that do not have the ability to measure interaction effects, and, for this case, it would be impossible to isolate the interaction term(s). However, tree-based ensembles are good at estimating interactions, as are other complex black-box models such as neural networks and support vector machines. The tools described below only work with \"interaction capable\" models.]. @eq-int-isolate is based on a simple parametric linear model. For models with more complex prediction equations, we can’t analytically pick out which model parameters should be used to investigate potential interactions. \n\nHowever, for any model, the joint and marginal effects can be quantified using _partial dependence profiles_ (PDP) (@molnar2020interpretable, [Section 8.1](https://christophm.github.io/interpretable-ml-book/pdp.html)). First, we determine a sequence of values covering the observed range of the predictor(s) of interest. Then we randomly sample a data point, perhaps from the training set, and over-ride the value of the predictor of interest with values from the grid. This produces a prediction profile over the grid. We can repeat this process many times to approximate $f(\\cdot)$ by averaging the multiple prediction values for each grid point. \n\n@fig-ensemble-pdp visualizes the PDP data derived from using the emsembles of regression trees for $f(hour)$, $f(day)$, and $f(hour, day)$. The first panel shows the random realizations of the relationship between delivery time and order hour from 1,000 randomly sampled rows of the training set. The results are unsurprising; we can see a similarity between these results and the initial visualizations in @fig-delivery-predictors. The single trend line in panel (b) is the average of these profiles for each value of the predictor (delivery hour). There appears to be, on average, a nonlinear effect of the delivery hour. The day of the week is an informative predictor and the _joint effect_ profile in panel (d) shows that its effect induces different patterns in the delivery hour. If this were not the case, the patterns in panels (b) and (c) would, when combined, approximate the pattern in panel (d).  \n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Partial dependence profiles for the food delivery hour and day, derived for the tree-based ensemble. Panel (a) shows the individual grid predictions from 1,000 randomly sampled points in the training set. The other panels show the average trends.](../figures/fig-ensemble-pdp-1.light.svg){#fig-ensemble-pdp fig-align='center' width=70%}\n:::\n:::\n\n\nFriedman’s H-statistic can quantify the effect of interaction terms using partial dependence profiles. When investigating two-factor interactions between predictors $j$ and $j'$, the statistic is \n\n$$\nH^2_{jj'}=\\frac{\\sum_\\limits{i=1}^B\\left[\\hat{f}(x_{ij},x_{ij'})-\\hat{f}(x_{ij})-\\hat{f}(x_{ij'})\\right]}{ \\sum_\\limits{i=1}^B\\hat{f}^2(x_{ij}, x_{ij'})}\n$$\n\nwhere the $\\hat{f}(x_{ij})$ term represents the partial dependence profile for predictor $j$ for sample point $i$ along the grid for that predictor and $B$ is the number of traning set samples.  The denominator captures the total joint effect of predictors $j$ and $j'$ so that $H^2$ can be interpreted as the fraction of the joint effect explained by the potential interaction. \n\nFor a set of $p$ predictors, we could compute all $p(p-1)/2$ pairwise interactions and rank potential interactions by their statistic values. This can become computationally intractable at some point. One potential shortcut suggested by the heredity principle is to quantify the importance of the $p$ predictors and look at all pairwise combinations of the $p^*$ most important values.  For $p^* = 10$, @fig-hstats-interaction shows the top five interactions detected by this procedure. We’ve already visually identified the hour $\\times$ day interaction, so seeing this in the rankings is comforting. However, another large interaction effect corresponds to the variables for items #1 and #10. Discovering this led us to visually confirm the effect back in @fig-delivery-items. \n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![$H^2$ statistics for the top ten pairwise interaction terms.](../figures/fig-hstats-interaction-1.light.svg){#fig-hstats-interaction fig-align='center' width=60%}\n:::\n:::\n\n\nNote that the _overall_ importance of the features are being quantified. From this analysis alone, we are not informed that the relationships between the hour and distance predictors and the outcome are nonlinear. It also doesn’t give any sense of the direction of the interaction (e.g., synergistic or antagonistic). We suggest using this tool early in the exploratory data analysis process to help focus visualizations on specific variables to understand how they relate to the outcome and other predictors. \n\nThere is a version of the statistic that can compute how much a specific predictor is interacting with _any other_ predictor. It is also possible to compute a statistical test to understand if the H statistic is different than zero. In our opinion, it is more helpful to use these values as diagnostics rather than the significant/insignificant thinking that often accompanies formal statistical hypothesis testing results.  \n\n@inglis2022visualizing discuss weak spots in the usage of the H-statistic, notably that correlated predictors can cause abnormally large values. This is an issue inherited from the use of partial dependence profiles [@apley2020]. \n\nAlternatively, @greenwell2018simple measures the potential for variables to interact by assessing the \"flatness\" over regions of the partial dependence profile. The importance of a predictor, or a pair of predictors, is determined by computing the standard deviation of the flatness scores over regions. For example, @fig-delivery-items shows a flat profile for the item 1 $\\times$ item 9 interaction while the item 1 $\\times$ item 10 interaction has different ranges of means across values of item 1. @fig-flat-interaction shows ten interactions with the largest flatness importance statistics. As with the $H^2$ results, the hour-by-day interaction. The two top ten lists have 6  other interactions in common. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Importance statistics for the top ten pairwise interaction terms.](../figures/fig-flat-interaction-1.light.svg){#fig-flat-interaction fig-align='center' width=60%}\n:::\n:::\n\n\nOther alternatives can be found in @hooker2004discovering, @herbinger2022repid, and @oh2022predictive.\n\nThe two PDP approaches we have described apply to any model capable of estimating interactions. There are also model-specific procedures for describing which joint effects are driving the model (if any). One method useful for tree-based models is understanding if two predictors are used in consecutive splits in the data. For example, @fig-reg-tree showed a shallow regression tree for the delivery time data. The terminal nodes had splits with orderings $\\text{hour}\\rightarrow\\text{hour}$ and $\\text{hour}\\rightarrow\\text{day} \\rightarrow\\text{distance}$ (twice). This implies that these three predictors have a higher potential to be involved in interactions with one another. \n\n@kapelner2013bartmachine describe an algorithm that counts how many times pairs of variables are used in consecutive splits in a tree. They demonstrate this process with Bayesian Adaptive Regression Trees (BART, Section TODO) which creates an ensemble of fairly shallow trees. @fig-bart-interaction shows the top ten pairwise interactions produced using this technique. Note that the BART implementation split categorical predictors via single categories. For the delivery data, this means that the tree would split on a specific day of the week (.i.e., Friday or not) instead of splitting all of the categories at once. This makes a comparison between the other two methods difficult. However, it can be seen that the hour $\\times$ day interaction has shown to be very important in all three methods. \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![BART model statistics identifying interactions by how often they occur in the tree rules.](../figures/fig-bart-interaction-1.light.svg){#fig-bart-interaction fig-align='center' width=60%}\n:::\n:::\n\n\nCaution should be exercised with this method. First, some tree ensembles randomly sample a subset of predictors for each split (commonly known as $m_{try}$). For example, if $m_{try} = 4$, a random set of four predictors are the only ones considered for that split point. This deliberately coerces non-informative splits; we are not using the best possible predictors in a split. This can dilute the effectiveness of counting predictors in successive splits. Second, as discussed in @sec-classification-trees, many tree-based splitting procedures disadvantage predictors with fewer unique values. For example, in the delivery data, the distance and hour predictors are more likely to be chosen for splitting than the item predictors _even if they are equally informative_.  There are splitting procedures that correct for this bias, but users should be aware of the potential impartiality. \n\nThe H-statistic and its alternatives can be an incredibly valuable tool for learning about the data early on as well as suggesting new features that should be included in the model. They are, however, computationally expensive. \n\n## Basis Expansions and Splines {#sec-splines}\n\n## Discretization\n\n\n## Sidebar: The Variance-Bias Tradeoff {#sec-variance-bias}\n\nOur discussion of basis expansions presents an excellent time for a segue to discuss an essential idea in statistics and modeling: the variance-bias tradeoff. This idea will be relevant in upcoming sections for resampling and specific models. At the end of this section, we’ll also connect it to @sec-effect-encodings. \n\nWhat does variance mean in terms of a machine learning model? In this context, it would quantify how much the fitted model changes if we slightly change the data. For example, would the curve change much if we repeat the data collection that produces the values in @sec-polynomials and fit the sample model (for a fixed sample size and polynomial degree)? We can also look at the _variance of prediction_: for a specific new data point $x_0$, how much intrinsic uncertainty is there? Similar to the discussion regarding extrapolation of global polynomials, we might want to compare how much the uncertainty changes as we move outside the training set’s range. \n\nBias is the difference between some estimate, like an average or a model prediction, and its true value. The true value is not the same as the data we collect; it is the unknowable theoretical value. For this reason, bias is often difficult to compute directly. For machine learning, the most pertinent idea of bias relates to how well a model can conform to the patterns we see in the data (hoping that the observed data is a good representation of the true values). Back in @fig-global-polynomial, we saw that a linear model didn’t fit the data well. This is due to simple linear regression being a high-bias model because, without additional feature engineering, it cannot replicate nonlinear trends. Adding polynomial or spline terms decreased the model’s bias since it was more flexible.\n\n::: {.important-box}\nWe can think of bias in terms of the question: \"How close are we _aiming_ to the center of the target?\" and variance as: \"How much do our results vary when shooting at the target?\"\n:::\n\nThe concepts of variance and bias are paired because they are often at odds with one another. For models that predict, we’d like a _low variance_, _low bias_ model. In many cases, that can be exceedingly difficult to achieve. We can often lower bias by adding model complexity. However, increased complexity usually comes at the expense of stability (i.e., high variance). We will often be in the position of trying to find an acceptable compromise between the two. This was discussed with global polynomials; linear models were bad for our data, but adding too many polynomial terms adds unnecessary complexity and an explosion of variance (reflected in the confidence bands). \n\nThis leads us to the mean squared error (MSE). We’ve seen the root mean squared error already where we used it as a measure of accuracy for regression models. More generally, we can write it in terms of some unknown parameter $\\theta$ and some estimate $\\hat{\\theta}$ based on statistical estimation from data: \n$$MSE = E\\left[(\\theta - \\hat{\\theta})^2\\right]$$\n\nIt turns out that the MSE is a combination of model variance and (squared) bias ($\\theta - \\hat{\\theta}$): \n\n$$MSE = E\\left[(\\theta - \\hat{\\theta})^2\\right] = Var[\\hat{\\theta}] + (\\theta - \\hat{\\theta})^2 + \\sigma^2$$\n\nwhere $\\sigma^2$ represents some unknown amount of \"irreducible noise.\" Because of this, MSE offers a statistic to minimize that accounts for both properties. This can offer a compromise between the two.  \n\nTo illustrate this, we simulated a simple nonlinear model: \n\n$$y_i = x_i^3 + 2\\exp\\left[-6(x_i - 0.3)^2\\right] + \\epsilon_i$$\n\nwhere the error terms are $\\epsilon_i \\sim N(0, 0.1)$ and the predictor values were uniformly spaced across [-1.2, 1.2]. Since we know the true values, we can compute the model bias. \n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nTo create a simulated data set, 31 samples were generated. Of these, 30 were used for the training set and one was reserved for the estimating the variance and bias. The test set values were roughly equally spaced across the range of the predictor. One simulated data set is shown in @fig-nonlinear-sim, along with the true underlying pattern.  \n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![A simulated data set with a nonlinear function.](../figures/fig-nonlinear-sim-1.light.svg){#fig-nonlinear-sim fig-align='center' width=70%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\nA linear model was estimated using ordinary least squares and a polynomial expansion for each simulated data set. The test set values were predicted, and the bias, variance, and root mean squared error statistics were computed. This was repeated 50,000 times for polynomial degrees ranging from one to twenty.  \n\n@fig-sim-results shows the average statistic values across model complexity (i.e., polynomial degree). A linear model performs poorly for the bias due to underfitting (as expected). In panel (a), adding more nonlinearity results in a substantial decrease in bias because the model fit is closer to the true equation. This improvement plateaus at a sixth-degree polynomial and stays low (nearly zero). The variance begins low; even though the linear model is ineffective, it is stable. Once additional terms are added, the variance of the model steadily increases then explodes around an 20<sup>th</sup> degree polynomial^[In this particular case, the variance becomes very large since the number of parameters is nearly the same as the number of training set points (30). This makes the underlying mathematical operation (matrix inversion) numerically unstable. Even so, it is the result of excessive model complexity.]. This shows the tradeoff; as the model becomes more complex, it fits the data better but eventually becomes unstable.\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![Simulation results showing variances, squared biases, and mean squared errors.](../figures/fig-sim-results-1.light.svg){#fig-sim-results fig-align='center' width=80%}\n:::\n:::\n\n\nThe mean squared error in panel (b) shows the combined effect of variance and bias. It shows a steep decline as we add more terms, then plateaus between seven and fifteenth-degree models. After that, the rapidly escalating variance dominates the MSE as it rapidly increases.  \n\nThe variance-bias tradeoff is the idea that we can exploit one for the other. Let’s go back to the basic sample mean statistic. If the data being averaged are normally distributed, the simple average is an _unbiased estimator_: it is always \"aiming\" for the true theoretical value. That’s a great property to have. The issue is that many unbiased estimators can have very high variance. In some cases, a slight increase in bias might result in a drastic decrease in variability. The variance-bias tradeoff helps us when one of those two quantities is more important. \n\n@fig-tradeoff shows a simple example. Suppose we have some alternative method for estimating the mean of a group that adds some bias while reducing variance. That tradeoff might be worthwhile if some bias will greatly reduce the variance. In our figure, suppose the true population mean is zero. The green curve represents the sample mean for a fixed sample size. It is centered at zero but has significant uncertainty. The other curve might be an alternative estimator that produces a slightly pessimistic estimate (its mean is slightly smaller than zero) but has 3-fold smaller variation. When estimating the location of the mean of the population, the biased estimate will have a smaller confidence interval for a given sample size than the unbiased estimate.  While the biased estimate may slightly miss the target, the window of the location will be much smaller than the unbiased estimate.  This may be a good idea depending on how the estimate will be used ^[This specific example will be referenced again when discussing resampling in @sec-resampling.].\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![A simnple example of the variance-bias tradeoff.](../figures/fig-tradeoff-1.light.svg){#fig-tradeoff fig-align='center' width=70%}\n:::\n:::\n\n\nThe categorical encoding approach shown in @eq-effect-posterior from @sec-effect-encodings is another example. Recall that $\\bar{y}_j$ was the average daily rate for agent $j$. That is an unbiased estimator but has high variance, especially for agents with few bookings. The more complex estimator $\\hat{y}_j$ in @eq-effect-posterior is better because it is more reliable. That reliability is bought by biasing the estimator towards the overall mean ($\\mu_0$). \n\nAs mentioned, we’ll return to this topic several times in upcoming sections. \n\n## Chapter References {.unnumbered}\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}