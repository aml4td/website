---
knitr:
  opts_chunk:
    cache.path: "../_cache/iterative/"
---

# Iterative Search {#sec-iterative-search}

```{r}
#| label: iterative-setup
#| include: false
source("../R/_common.R")

# ------------------------------------------------------------------------------

library(kableExtra)
library(tidymodels)
library(finetune)
library(patchwork)
library(future)
library(bestNormalize)
library(kableExtra)
library(GA)

# ------------------------------------------------------------------------------
# Set Options

plan("multisession")
tidymodels_prefer()
theme_set(theme_transparent())
set_options()

num_workers <- parallel::detectCores()
```

Grid search is a static procedure; we predetermine which candidates will be evaluated before beginning. How can we adaptively optimize tuning parameters in a sequential manner? Perhaps more importantly, _when_ is this a good approach? 

Previously, we’ve seen that a plateau of good performance in the parameter space is possible. This is often the case but will not always be true. If the region of optimal performance is small, we must create a large space-filling design to find it. When there are many tuning parameters, the computational expense can be unreasonable. An even worse situation is one where the previously described speed-up techniques (such as the submodel trick from @sec-submodels) are not applicable. Racing can be very efficient, but if the training set is very large, it may be that using a validation set is more appropriate than multiple resamples; in this case, racing cannot be used. Finally, there are practical considerations when the data set is very large. Most parallel processing techniques require the data to be in memory for each parallel worker, restricting their utility. 

Generally, we are not often constrained by these issues _for models used for tabular data_. However, there are a few models that might be better optimized sequentially. The first two that come to mind are large neural networks^[Sections [-@sec-cls-svm] and [-@sec-reg-svm]]. and support vector machines^[Sections [-@sec-cls-nnet] and [-@sec-reg-nnet]] (SVMs) [@scholkopf2001;@cristianini2004]. For the former, as the number of layers increases, so does the number of tuning parameters. Neural networks also have many important tuning parameters associated with the model’s training, such as the learning rate, regularization parameters, etc. These models also require more preprocessing than others; they are suspectable to the effects of uninformative predictors, missing data, and collinearity. Depending on the data set, there can be many pre-model tuning parameters. 

Support vector machines are models with fewer tuning parameters than neural networks but with similar preprocessing requirements. Unfortunately, the tuning parameter space can have large areas of poor performance with "islands" where the model works well. The location of these will change from data set to data set. We’ll see an example of this shortly where two model parameters are tuned.

These two models, in particular, are more likely to benefit from an optimization method that chooses candidates as the process evolves. 

In theory, any iterative optimization procedures can be used. In general, gradient methods, such as steepest descent or Newton’s method, are the most commonly used technique for nonlinear optimization. These tools are suboptimal when it comes to parameter tuning but play important parts in other areas of machine learning and, for this reason, they will be discussed later. 

Derivative-free techniques can be helpful for model tuning. Traditional examples are genetic algorithms, simulated annealing, particle swarm optimization, etc. We’ll consider the first two of these in Sections [-@sec-sim-anneal] and [-@sec-genetic-algo]. Currently, the most well-known iterative tool for tuning models is Bayesian optimization. This will be examined in @sec-bayes-opt. However, before this, @sec-bayes will flesh out what it means for a model to be Bayesian. 

To get started, let's revisit a data set. 

## Example: Predicting Barley Amounts using Support Vector Machines {#sec-barley-svm}

```{r}
#| label: data-import
#| include: false
source("../R/setup_chemometrics.R")
```

We’ll return to the data previously seen in @sec-barley where we want to predict the percentage of barley oil in a mixture. Recall that the predictors are extremely correlated with one another. In @sec-embeddings, we considered embedding methods like PCA to preprocess the data and these models were able to achieve RMSE values of about 6% (shown in @fig-barley-linear-bakeoff). 

In this chapter, we’ll model these data in two different scenarios. First, we’ll use them as a "toy problem" where only two tuning parameters are optimized for a support vector machine model. This is a little unrealistic, but it allows us to visualize how iterative search methods work in a 2D space. Second, in @sec-bayes-opt-nnet, we’ll get serious and optimize a larger group of parameters for neural networks simultaneously with additional parameters for a specialized preprocessing technique. 

Let's start with the toy example that uses an SVM regression model. This highly flexible nonlinear model can represent the predictor data in higher dimensions using a _kernel transformation_ [@hofmann2008]. This type of function combines numeric predictor vectors from two data points using a dot product. There are many different types of kernel functions, but for a _polynomial_ kernel, it is: 

$$
k(\boldsymbol{x}_1, \boldsymbol{x}_2) = (a\boldsymbol{x}_1'\boldsymbol{x}_2 + b)^q
$$ {#eq-kernel-poly}

where $a$ is called the scaling factor, $b$ is a constant offset value, and $q$ is the polynomial degree. The dot product of predictor vectors ($\boldsymbol{x}_i$) measures both angle and distance between points. Note that for the kernel function to work in an appropriate way, the two vectors must have elements with consistent units (i.e., they have been standardized). 

The kernel function operates much like a polynomial basis expansion; it projects a data point into a much larger, nonlinear space. The idea is that a more complex representation of the predictors might enable the model to make better predictions. 

For our toy example, we'll take the `r ncol(barley_train) - 1` predictors, project them to a reduced space of 10 principal components, and standardize those features to have the same mean and standard deviation. A quartic polynomial with zero offset is applied, and the scale parameter, $a$, will be tuned. This parameter helps define how much influence the dot product has in the polynomial expansion. 

The most commonly adjusted parameter in SVMs is the cost value, which is independent of the chosen kernel function. This parameter determines how strongly the model is penalized for incorrect predictions on the training set. A higher cost value pushes the SVM to create a more complex model. As shown earlier in @fig-two-class-overfit, small cost values result in the SVM making less effort to classify samples correctly, leading to underfitting. In contrast, extremely high cost values cause the model to overfit to the training set.

Just as in @sec-embeddings, the RMSE will be computed from a validation set and these statistics will be used to guide our efforts. 

Let's define a wide  space for our two tuning parameters: cost will vary from 2<sup>-10</sup> to 2<sup>10</sup> and the scale factor^[Why do these two parameters use different bases? It’s mostly a convention. Both parameters have valid values that can range across many orders of magnitude. The change in cost tends to occur more slowly than the scaling factor, so a smaller base of 2 is often used.] is allowed to range from 10<sup>-10</sup> to 10<sup>-0.1</sup>. 

@fig-svm-grid visualizes the RMSE across these ranges^[These are not simulated data, so this surface is an approximation of the true RMSE via the validation set using a very large regular grid. The RMSE results are estimates and would change if we used different random numbers for data splitting.] where darker colors indicate smaller RMSE values. The lower left diagonal area is a virtual "dead zone" with very large RMSE results that don't appear to change much. There is also a diagonal wedge of good performance (symbolized by the darker colors). The figure shows the location of the smallest RMSE value and a diagonal ridge of parameter combinations with nearly equal results. Any points on this line would produce good models (at least for this toy example). Note that there is a small locale of excessively large RMSE values in the upper right.  Therefore, increasing both tuning parameters to their upper limits is a bad idea.  

```{r}
#| label: svm-spec
#| include: false
rec <-
  recipe(barley ~ ., data = barley_train) %>%
  step_orderNorm(all_predictors()) %>% 
  step_pca(all_predictors(), num_comp = tune()) %>%
  step_normalize(all_predictors())

svm_spec <-
  svm_poly(cost = tune(), degree = tune(), scale_factor = tune(), margin = tune()) %>%
  set_mode("regression")

svm_wflow <- workflow(rec, svm_spec)

svm_param <-
  svm_wflow %>%
  extract_parameter_set_dials() %>%
  update(
    num_comp = num_comp(c(1, 200)),
    cost = cost(c(-10, 10)),
    degree = degree_int(c(1, 8)),
    scale_factor = scale_factor(c(-10, -1/10))
  )

reg_mtr <- metric_set(rmse)
```

```{r}
#| label: fig-svm-grid
#| echo: false
#| fig-width: 5
#| fig-height: 5
#| out-width: 50%
#| fig-cap: "A visualization of model performance when only the SVM cost and scaling factor parameters are optimized. It shows the combination with the smallest RMSE and a ridge of candidate values with nearly equivalent performance."

load("../RData/two_param_iter_large.RData")
x_rng <- 10^extendrange(c(-10, -1/10))
y_rng <- 2^extendrange(c(-10, 10))

log10_labs <- trans_format("log10", math_format(10^.x, function(x) format(x, digits = 3)))
log2_labs <- trans_format("log2", math_format(2^.x, function(x) format(x, digits = 3)))

num_cuts <- 50
rd_or <- colorRampPalette(rev(RColorBrewer::brewer.pal(9, "OrRd")))(num_cuts)

regular_mtr %>%
  mutate(RMSE = cut(mean, breaks = seq(5, 31, length = num_cuts))) %>% 
  ggplot(aes(scale_factor, cost)) +
  geom_tile(aes(fill = RMSE)) +
  geom_point(data = regular_mtr %>% slice_min(mean), col = "grey", cex = 3) + 
  geom_line(
    data = regular_mtr %>% slice_min(mean, n = 18),
    stat = "smooth",
    col = "grey",
    method = lm,
    se = FALSE,
    formula = y ~ x,
    alpha = 1,
    linewidth = 1
  ) +
  scale_x_log10(limits = x_rng,
                labels = log10_labs,
                expand = expansion(add = c(-1 / 5, -1 / 5))) +
  scale_y_continuous(limits = y_rng, trans = "log2", labels = log2_labs,
                     expand = expansion(add = c(-1/2, -1/2))) +
  scale_fill_manual(values = rd_or) +  
  labs(x = "Scaling Factor", y = "Cost") +
  coord_fixed(ratio = 1/2) +
  theme_bw() +
  theme(legend.position = "none")
```

In the next section, we explore gradient descent optimization and explain why it may not be suitable for model tuning. Following that, we delve into two traditional global search methods—simulated annealing and genetic algorithms—and their application in parameter space exploration. We then shift our focus to Bayesian optimization, concluding with an in-depth analysis of the barley prediction problem.

## Sidebar: Gradient-Based Optimization {#sec-gradient-opt}

To formalize the concept of optimization, we need an objective function that defines what we are trying to optimize.  This function, often called a loss function (specifically to be minimized), is denoted by $\psi()$.  The parameters that modify $\psi()$ are represented by $\boldsymbol{\theta}$, a $p \times 1$ vector of real numbers.  For simplicity, we will assume that $\psi()$ is smooth and generally differentiable.  Additionally, without loss of generality, we will assume that _smaller_ values of $\psi()$ are better.

We’ll denote the first derivative ($\psi'(\boldsymbol{\theta})$), for simplicity, as $g(\boldsymbol{\theta})$ ($p\times 1$). The matrix of second deriviatives, called the Hessian matrix, is symbolized as $H(\boldsymbol{\theta})$ ($p\times  p$). 

We start with an initial guess, $\boldsymbol{\theta}_0$, and compute the gradient at this point, yielding a $p$-dimensional directional vector. To get to our next parameter value, simple gradient descent uses the update:

$$
\boldsymbol{\theta}_{i+1} = \boldsymbol{\theta}_i - \alpha\:g(\boldsymbol{\theta}_i)
$$ {#eq-gd-step}

The value $\alpha$ defines how far to move in the chosen direction. It can either be a fixed constant^[We’ve seen $\alpha$ before when it was called the learning rate (and will revisit it later in this chapter).] or adjusted using a secondary method called a line search. In a line search, $\alpha$ is incrementally increased until the objective function worsens.

We proceed to iterate this process until some measure of convergence is achieved. For example, the optimization could be halted if the objective function does not improve more than a very small value. @lu2022gradient and @zhang2019gradient are excellent introductions to gradient-based optimization that is focused on training models.

As a simple demonstration, @fig-grad-descent shows $\psi(\theta) = \theta\: cos(\theta/2)$ for values of $\theta$ between $\pm 10.0$. We want to minimize this function. There is a _global_ minimum at about $\theta \approx `r round(optimize(function(x) x * cos(.5 * x) , c(-6, 10))$minimum, 2)`$ while there are _local_ minima at $\theta = -10.0$ and $\theta \approx `r round(optimize(function(x) x * cos(.5 * x) , c(-6, 0))$minimum, 2)`$. These are false solutions where some search procedures might become trapped. 

:::: {.columns}

::: {.column width="5%"}
:::

::: {.column width="90%"}

::: {#fig-grad-descent}

::: {.figure-content}

```{shinylive-r}
#| label: fig-grad-descent
#| viewerHeight: 600
#| viewerWidth: "100%"
#| standalone: true
library(shiny)
library(bslib)
library(ggplot2)
library(dplyr)

source("https://raw.githubusercontent.com/aml4td/website/main/R/shiny-setup.R")
# source("https://raw.githubusercontent.com/aml4td/website/main/R/shiny-gd.R")
# 
# app
```

:::

An example of simple gradient descent for the function $\psi(\theta) = \theta\: cos(\theta/2)$.

:::

:::

::: {.column width="5%"}
:::

:::: 

The figure enables the choice of $\theta_0$, the value of $\alpha$, and how many iterations to used. Consider a few configurations:

- Starting at $\theta = 3$, a learning rate of $\alpha = 2.0$ is inappropriate. The search initially moves towards the global minimum but then reverses course and jumps past the best value, then becomes trapped around one of the local optima. 

- If we keep $\theta = 3$ and decrease learning rate to $\alpha = 1.0$, we quickly find the best result. 

- However, if we tried decreasing the learning rate too low, say $\alpha = 0.01$, the optimization moves too slowly. 

The learning rate plays a crucial role in the optimization process. Additionally, the starting value is significant; values below 2.0 consistently fail to reach the optimum.

This gradient descent algorithm outlined above is extremely basic. There are far more complex versions, the most well-known of which is the Newton-Raphson method (a.k.a. Newton’s Method) that incorporates the second derivative matrix $H(\boldsymbol{\theta})$ in the updating formula^[However, computing the Hessian matrix increases the computational cost by about 3-fold.]. 

We often know _when_ gradient-based optimization will work well. If we know the equation for the objective function, we can determine its properties, such as whether it is a convex function, and theory can tell us if a global optimum can be found via the use of gradients. For example, squared error loss $\psi(\boldsymbol{\theta}) = (y-\hat{y})^2$, is convex when  the relationship for the predicted value $\hat{y}$ is a well-behaved function of $\boldsymbol{\theta}$ (such as in linear regression). 

However, there are additional considerations when it comes to optimizations for predictive models. First, since data are not deterministic, the loss function is not only a random variable but can be excessively noisy. This noise can have a detrimental effect on how well the optimization proceeds. 

Second, our objective function is often a performance metric, such as RMSE. However, not all metrics are mathematically well-behaved—they may lack smoothness or convexity. In the case of deep neural networks, even when the objective function is simple (e.g., squared error loss), the model equations can create a non-convex optimization landscape. As a result, the optimized parameters may correspond to a local optimum rather than a global one.

This issue arises because traditional gradient-based methods are inherently _greedy_. They optimize by moving in the direction that appears most favorable based on the current estimates of $\boldsymbol{\theta}$. While this approach is generally effective, it can lead to the optimization process becoming trapped in a local optimum, particularly with complex or non-standard objective functions.

There are additional complications when the tuning parameters, $\boldsymbol{\theta}$, are not real numbers. For instance, the number of spline terms is an integer, but the update equation might produce a fractional value for this number. Other parameters are qualitative, such as the choice of activation function in a neural network, which cannot be represented as continuous numerical values.

During model tuning, we know to avoid repredicting the training set (due to overfitting). Procedures such as resampling make the evaluation of $\psi()$ computationally expensive since multiple models should be trained. Unless we use symbolic gradient equations, the numerical process of approximating the gradient vector $g(\boldsymbol{\theta})$ can require a large number of function evaluations. 

Later, we’ll discuss *stochastic gradient descent* (SGD) [@udl2023, Chapter 6]. This method is commonly used to train complex networks with large amounts of training data. SGD approximates the gradient by using only a small subset of the data at a time. Although this introduces some variation in the direction of descent, it can be beneficial as it helps the algorithm escape from local minima. Additionally, when dealing with large datasets, computer memory may not be able to store all the data at once. In such cases, SGD is often the only viable option because it doesn't require the entire dataset to be loaded into memory and can also be much faster.

Until then, the next three chapters will describe different stochastic optimization, gradient-free  methods that are well-suited for parameter tuning since they can sidestep some of the issues described above. 

## Simulated Annealing  {#sec-sim-anneal}

```{r}
#| label: sa-example-calcs
#| echo: false
load(url("https://raw.githubusercontent.com/aml4td/website/main/RData/two_param_iter_sa.RData"))

sa_history <- 
  sa_history %>% 
  mutate(
    log_cost = signif(log2(cost), digits = 3),
    log_scale = signif(log10(scale_factor), digits = 3),
    RMSE = sprintf("%3.2f", mean)
  )

best_iters <- sa_history$.iter[sa_history$results == "new best"]
restart_iters <- sa_history$.iter[sa_history$results == "restart from best"]
  
best_initial <- 
  sa_history %>% 
  filter(.iter == 0) %>% 
  slice_min(mean)

best_overall <- 
  sa_history %>% 
  slice_min(mean)

iter_1 <- 
  sa_history %>% 
  filter(.iter == 1) 

sa_0 <- cli::format_inline("({best_initial$log_cost}, {best_initial$log_scale})")
sa_1 <- cli::format_inline("({iter_1$log_cost}, {iter_1$log_scale})")
```

Non-greedy search methods are not constrained to always proceed in the absolute best direction (as defined by the gradient). One such method is _simulated annealing_ (SA)[@spall2005introduction;@kirkpatrick1983optimization]. It is a controlled random search that moves in random directions but with some amount of control over the path. It can also incorporate restarts if the algorithm moves into clearly poor regions.

Given an initial solution, simulated annealing (SA) creates a random perturbation of the current candidate solution, typically within a small local neighborhood. The objective function is then evaluated for the new candidate and compared to the previous solution. If the new candidate results in an improvement, the process moves forward by using it to make the next step. If the new candidate is worse, there are two options: 

 - We can accept the current solution as "suboptimal" and use it as the basis for the next perturbation, or
 - we can discard the current solution and treat it as if it never occurred. The next candidate point will then be a perturbation of the last "acceptable" solution.

For our SVM example, suppose we start with a candidate where $x_0 = \left[log_2 (cost), log_{10} (scale)\right[$ was $x_0 = [-10, -0.1]$ and had an associated RMSE value of 6.10%. For the next candidate, a perturbation of this values is created, say $x_1 = [-7.11, -0.225]$. Suppose that the corresponding RMSE was measured at 5.97%. Since $x_1$ has a better performance metric it is automatically accepted and is used to create the next parameter. 

However, suppose that the RMSE value for $x_1$ was 7.00%, meaning that the new candidate did worse than the initial one.  In this case, simulated annealing generates a probability threshold for accepting the worse solution.  Typically, the probability depends on two quantities:

Simulated annealing generates a probability threshold for accepting the worse solution. Typically, the probability depends on two quantities: 

* The difference between the current and previous objective function values. If the new candidate is nearly as good as the current solution, the probability of acceptance will be higher compared to a candidate that is significantly worse.
* The probability of acceptance should decrease over time as the search progresses. This is often achieved using an exponentially decaying function, known as the "cooling schedule."

An often used equation for the probability, assuming that smaller values are better, is 

$$
Pr[accept] = \exp\Bigl[-i\bigl(\hat{Q}(\boldsymbol{\theta}_{i}) - \hat{Q}(\boldsymbol{\theta}_{i-1})\bigr)\Bigr]
$$

where $i$ is the iteration number. To compare 6.1% versus 7.0%, the acceptance probability is `r signif(exp(-(7-6.10)), 3)`. To make the determination, a random uniform number $\mathcal{U}$ is generated and, if $\mathcal{U} \le Pr[accept]$,  we accept $\boldsymbol{\theta}_{i}$ and it is used to make $\boldsymbol{\theta}_{i+1}$. Note that the probability "cools" over time; if this difference were to occur at a later iteration, say $i = 5$, the probability would drop to `r signif(exp(-5*(7-6.10)), 3)`.

One small matter is related to the scale of the objective function. The difference in the exponent is very sensitive to scale. If, for example, instead of percentages we were to use the proportions 0.61 and 0.70, the probability of acceptance would change from `r round(exp(-(7-6.10)) * 100, 1)`% to `r round(exp(-(.7-.610)) * 100, 1)`%. One way to mitigate this issue is to use a normalized difference by dividing the raw difference by the previous objective function (i.e., (0.70-0.61) / 0.70). This is the approach used in the SA analyses here.

This process continues until either a pre-defined number of iterations is reached or there is no improvement after a certain number of iterations. The best result found during the optimization process is used as the final value, as there is no formal concept of "convergence" for this method. Additionally, as mentioned earlier, a restart rule can prevent simulated annealing from getting stuck in suboptimal regions if no better results have been found within a certain timeframe. When the process is restarted, it can either continue from the best candidate found in previous iterations or start from a random point in the parameter space.

How should the candidates be perturbed from iteration to iteration? When the tuning parameters are all numeric, we can create a random distance and angle from the current values. A similar process can be used for integers by "flooring" them to the nearest whole number. For qualitative tuning parameters, a random subset of parameters is chosen to change to a different value chosen at random. The amount of change should be large enough to search the parameters space and potentially get out of a local optimum.

It is important to perform computations on the parameters in their transformed space to ensure that the full range of possible values is treated equally. For example, when working with the SVM cost parameter, we use its log (base 2) scale. When perturbing the parameter values, we make sure to adjust them in the log space rather than the original scale. This approach applies to all other search methods discussed in this chapter.

To illustrate, a very small initial space-filling design with three candidates was generated and evaluated. The results are in @tbl-svm-initial. To start the SA search^[These values will be also used as the initial substrate for Bayesian optimization.], we will start with the candidate with the smallest RMSE and proceed for 50 iterations without a rule for early stopping. A restart to the last known best results was enforced after eight suboptimal iterations. 

:::: {.columns}

::: {.column width="25%"}
:::

::: {.column width="50%"}

::: {#tbl-svm-initial}

```{r}
#| label: tbl-svm-initial
#| echo: false
sa_history %>% 
  filter(.iter == 0) %>% 
  arrange(mean) %>% 
  select(RMSE, log_cost, log_scale) %>% 
  kable(
    digits = 1,
    col.names  = c("RMSE (%)", "Cost (log-2)", "Scale (log-10)")
  ) %>% 
  kable_styling(bootstrap_options = "responsive", full_width = FALSE)

load(url("https://raw.githubusercontent.com/aml4td/website/main/RData/two_param_iter_initial.RData"))
```

The initial set of candidates used for iterative search with the toy example from @fig-svm-grid. One candidate does poorly while the other two have relatively similar results. 

:::

:::

::: {.column width="25%"}
:::

:::: 
 
@fig-sa-example contains an animation of the results of the SA search. In the figure, the initial points are represented by open circles, and a grey diagonal line shows the ridge of values that corresponds to the best RMSE results. 

:::: {.columns}

::: {.column width="15%"}
:::

::: {.column width="70%"}

::: {#fig-sa-example}

::: {.figure-content}

```{shinylive-r}
#| label: fig-sa-example
#| viewerHeight: 600
#| viewerWidth: "100%"
#| standalone: true
library(shiny)
library(bslib)
library(ggplot2)
library(dplyr)
library(purrr)
library(scales)

source("https://raw.githubusercontent.com/aml4td/website/main/R/shiny-setup.R")
# source("https://raw.githubusercontent.com/aml4td/website/main/R/shiny-sa.R")
# 
# app
```

:::

An example of how simulated annealing can investigate the tuning parameter space. The open circles represent a small initial grid. The thick diagonal grey light is a ridge where the model has the smallest RMSE. The asterisk denotes the current best candidate.

:::

:::

::: {.column width="15%"}
:::

:::: 

During the search, there were `r cli::format_inline("{length(best_iters)} iteration{?s}")` where a new global best result was discovered (iterations `r cli::format_inline("{best_iters}")`). There were also `r cli::format_inline("{length(restart_iters)} restart{?s}")`  at iterations `r cli::format_inline("{restart_iters}")`. In the end, the best results occurred with a cost value of 2<sup>`r best_overall$log_cost`</sup> and a scale factor of 10<sup>`r round(best_overall$log_scale, 2)`</sup>. The corresponding validation set RMSE was `r round(best_overall$mean, 2)`%. With this random seed, the search gets near the ridge of best performance shown in @fig-svm-grid but only lingers there for short times. It does spend a fair amount of time meandering in regions of poor performance. 

Simulated annealing has several attractive qualities. First, the process of generating new candidates works with any type of parameter, whether real, integer, or qualitative. This is not true for the other two iterative methods we’ll discuss. Additionally, the perturbation process is very fast, meaning there is minimal computational overhead to compute the next objective function value. Since we are effectively generating new candidate sets, we can also apply constraints to individual parameters or groups of parameters. For example, if a tuning parameter is restricted to odd integers, this would not pose a significant problem for simulated annealing.

There are a few downsides to this method. Compared to the other search methods, SA makes small incremental changes. If we start far away from the optimum, many iterations might be required to reach it.  One way to mitigate this issue is to do a small space-filling design and start from the best point (as we did). In fact, applying SA search after a grid search (perhaps using racing) can be a good way to verify that the grid search was effective. 

Another disadvantage is that a single candidate is processed at a time. If the training set size is not excessive, we could parallel process the multiple candidates simultaneously. We could make a batch of perturbations and pick the best value to keep or apply the probabilistic process of accepting a poor value. 

This optimization took `r prettyunits::pretty_sec((initial_time[3] + sa_time[3]) / nrow(sa_history))` per candidate to execute for these data. 

## Genetic Algorithms  {#sec-genetic-algo}

Genetic algorithms (GAs) [@Mitchell1996AnIT; @eiben2015introduction] are an optimization method that mimics the process of evolution through natural selection. While GAs are not ideally suited for parameter tuning in our case—since a standard GA search typically requires hundreds to millions of objective function evaluations—we will limit the search to a smaller scale for practical reasons. Nevertheless, genetic algorithms can often find solutions near the optimal value fairly quickly. Additionally, as previously mentioned, there is usually a region of acceptable candidates. Finally, GAs are highly unlikely to become trapped in a locally optimal solution.

Instead of search iterations, genetic algorithms are counted in _generations_. A generation is a group of candidate values that are evaluated at the same time (as a batch)^[Think of the candidates within a generation as a population of people.]. Once their corresponding performance metrics are computed, a small set of the best candidates is selected and is used to create the next generation via _reproduction_. Reproduction would entail combining a pair of "parent" candidates by swapping information^[Analogous to chromosomes.], and then random mutations can be applied. Once the next generation is created, the process continues for some pre-defined time limit or maximum number of generations. 

How, exactly, does this work? The first step is to pick a numerical representation for each candidate. Let’s consider methods for our main types of data. 

#### Real-Valued Parameters {.unnumbered}

For real numbers, there are two encoding methods: one option is to keep them as-is (i.e., floating point values) and another converts the values to a binary encoding.

When keeping the values as real numbers, we can make two children from a pair of well-performing candidates via a linear combination. For candidate vectors $\boldsymbol{\theta}_j$, we can use:

$$
\begin{align}
\boldsymbol{\theta}^{\:kid}_1 &= \alpha \boldsymbol{\theta}^{\:par}_1 + (1 - \alpha) \boldsymbol{\theta}^{\:par}_2 \notag \\
\boldsymbol{\theta}^{\:kid}_2 &= (1-\alpha) \boldsymbol{\theta}^{\:par}_1 + \alpha \boldsymbol{\theta}^{\:par}_2 \notag \\
\end{align}
$$

where $\alpha$ is a random standard uniform number. Notice that the two children's candidate values will always be in-between the values of their parents. 

For mutation, a candidate’s values are either locally perturbed or simulated with rate $\pi_m$. For example, we might mutate the log cost value by simulating a random number across the range that defines its search space. 

Binary encodings for real numbers were suggested in the early days of genetic algorithms. In this case, each candidate value is encoded as a set of binary integers. For example, consider a log<sub>2</sub> cost value of -2.34. To convert this to binary, we multiply it by 100 (assuming a limit of two decimal places) to convert it to an integer. If we use 8 binary digits (a.k.a. "bits") to represent 234, we get ``r GA::decimal2binary(234) %>% paste(collapse = "")``. If the candidates could have both positive and negative numbers, we can add an extra bit at the start that is 1 when the value is positive, yielding:  ``r GA::decimal2binary(234) %>% c(0, .) %>% paste(collapse = "")``. 

The method of _cross-over_ was often used for the reproduction of binary representations. For a single cross-over, a random location between digits was created for each candidate value, and the binary digits were swapped. For example, a representation with five bits might have parents `ABCDE` and `VWXYZ.`  If they were crossed over between the second and third elements, the children would be `ABXYZ` and `VWCDE`. There are reproduction methods that use multiple cross-over points to create a more granular sharing of information. 

There are systematic bias that can occur when crossing binary representations as described by @rana1999distributional and @Soule2009. For example, there are positional biases. For example, if the first bits (`A` and `V`) capture the sign of the value, the sign is more likely to follow the initial bits than the later bits to an offspring. 

For mutating a binary representation, each child’s bit would be flipped at a rate of $\pi_m$. 

After these reproduction and mutation, the values are decoded into real numbers. 

#### Integer Parameters {.unnumbered}

For integers, the same approach can be used as real numbers, but after the usual operations, the decimal values are coerced to integers via rounding. If a binary encoding is used, the same process can be used for integers as real numbers; they are all just bits to the encoding process. 

#### Qualitative Parameters {.unnumbered}

For qualitative tuning parameters, one (inelegant) approach is to encode them into values on the real line or as integers. For example,  for a parameter with values "red,", "blue," and "green", we could map them to bins of `[0, 1/3)`, `[1/3, 2/3)`, and `[2/3, 1]`. From here, we reproduce and mutate them as described above, then convert them back to their non-numeric categories. This is more palatable when there is a natural ordering of the values but is otherwise a workable but unfortunate approach. Mutation is simple though; at rate $\pi_m$, a value is flipped to a random selection of the possible values.

### Assembling Generations {#sec-ga-generations}

Now that we know how to generate new candidates, we can form new generations. The first step is to determine the population size. Typically, the minimum population size within a generation is 25 to 50 candidates. However, this may be infeasible depending on the computational cost of the model and the characteristics of the training set, such as its size. While fewer candidates can be used, the risk is that we may fail to sample any acceptable results. In such cases, combining the best results will only produce more mediocre candidates. Increasing the mutation rate can help mitigate this issue. For the first iteration, random sampling of the parameter space is commonly used. It is highly recommended to use a space-filling design for the initial candidate set to ensure a more comprehensive exploration. 

Finally, there is the choice of which candidates to reproduce at each generation. There are myriad techniques for selecting which candidates are used to make the next generation of candidates. The simplest is to pick two parents by randomly selecting them with probabilities that are proportional to their performance (i.e., the best candidates are chosen most often). There is also the idea of _elitism_ in selection. Depending on the size of the generation, we could retain a few of the best-performing candidates from the previous generation. The performance values of these candidates would not have to be recomputed (saving time), and their information is likely to persist in a few good candidates for the next generation.

### Two Parameter Example {#sec-2D-example}

```{r}
#| label: ga-descr
#| echo: false

load(url("https://raw.githubusercontent.com/aml4td/website/main/RData/two_param_iter_ga.RData"))

ga_history <- ga_history %>% filter(generation <= 5)
  
best_by_gen <- 
  ga_history %>% 
  slice_min(fitness, by = c(generation)) %>% 
  distinct(fitness, generation)

is_same_as_gen_1 <- best_by_gen$fitness == best_by_gen$fitness[1]
same_as_gen_1 <- sum(is_same_as_gen_1) - 1

other_best <- round(unique(best_by_gen$fitness[!is_same_as_gen_1]), 3)
other_best <- paste0(other_best, "%")
```

To illustrate genetic algorithms in two dimensions, a population size of 8 was used for 7 generations. These values are _not_ optimal defaults but were selected to align with the previous SA search and the optimization method discussed in the next section. The two tuning parameters were kept as floating-point values. Parental selection was based on sampling weights proportional to the RMSE values (with smaller values being better). The mutation rate was set at 10%, and elitism was applied by retaining the best candidate from each generation. All computations within a generation were performed in parallel. On average, the optimization took `r prettyunits::pretty_sec(ga_time[3] / nrow(ga_history))` per candidate.  @fig-ga-example illustrates the results of the search.   

:::: {.columns}

::: {.column width="15%"}
:::

::: {.column width="70%"}

::: {#fig-ga-example}

::: {.figure-content}

```{shinylive-r}
#| label: fig-ga-example
#| viewerHeight: 600
#| viewerWidth: "100%"
#| standalone: true
library(shiny)
library(bslib)
library(ggplot2)
library(dplyr)
library(purrr)
library(scales)

source("https://raw.githubusercontent.com/aml4td/website/main/R/shiny-setup.R")
# source("https://raw.githubusercontent.com/aml4td/website/main/R/shiny-ga.R")
# 
# app
```

:::

Several generations of a genetic algorithm that search tuning parameter space. The thick diagonal grey light is a ridge where the model has the smallest RMSE. The asterisk denotes the current best candidate.

:::

:::

::: {.column width="15%"}
:::

:::: 

A space-filling design was used to ensure that the initial population was diverse. Fortuitously, one design point was very close to the ridge, with an RMSE of `r round(best_by_gen$fitness[1], 2)`%.  After this, there `r cli::format_inline("{?was/were} {length(other_best)} generations with better candidate{?s}")` (with almost identical performance): `r cli::format_inline("{other_best}")`. We can see that, after three generations, the search is concentrated around the ridge of optimal performance. In later generations, some candidates have outliers in one dimension; this is the effect of mutation during reproduction. 

### Summary {#sec-ga-summary}

This small toy example is not ideal for demonstrating genetic algorithms. The example’s low parameter dimensionality and the relatively low computational cost per candidate might give the impression that genetic algorithms are a universal solution to optimization problems. While genetic algorithms are versatile and powerful tools for global optimization, they come with limitations. Like simulated annealing, they have minimal overhead between generations, but in most real-world applications, there are more than just two parameters. This typically means that larger populations and more generations are needed. If the dataset is not excessively large, parallel processing can help manage the increased computational demands.^[If you have access to high-performance computing infrastructure,  the parallel processing can run the individuals in the population in parallel and, within these, any resampling iterations can also be parallelized.]. 

Now we'll take a look at what makes a Bayesian model Bayesian.

## Sidebar: Bayesian Models {#sec-bayes}

We've superficially described an application of Bayesian analysis in @sec-effect-encodings. Before discussing Bayesian optimization, we should give a general description of Bayesian analysis, especially since it will appear again several times after this chapter. 

Many models make probabilistic assumptions about their data or parameters. For example, a linear regression model has the form

$$
y_i = \beta_0 + \beta_1x_1 + \cdots + \beta_px_p + \epsilon_i
$$

Using ordinary least squares estimation, we can make assumptions regarding the model errors ($\epsilon_i$). We can assume that the residuals are independent of one another and follow a Gaussian distribution with zero mean and a constant standard deviation. From there, it follows that the regression parameters ($\beta$ coefficients) also follow Gaussian distributions. 

Based on these assumptions, our objective function is the Gaussian likelihood function, generally denoted as $\ell(z|\theta)$, although we often maximize the log of this value. We fix the outcome and predictor data and try to find values of $\sigma$ and the $\beta$  parameters that maximize the objective function (log $\ell(z|\theta)$). This process is maximum likelihood estimation. 

::: {.important-box}
One important point is that each model parameter is treated as a single value. Our maximum likelihood estimate (MLE) is a point estimate and, based on our assumptions about the residuals, we know the distribution of the MLEs. 
:::

The consequence of this is that we cannot make inferences about the true, unknown model parameters since they are considered to be single points. Instead, our inference focuses on the MLEs. This leads to the circuitous explanation of hypothesis tests and confidence intervals. For example, the explaination of a 90% confidence interval is:

> "We believe that if we were to repeat this experiment a large number of times, the true parameter value would fall between $L$ and $U$ 90% of the time." 

A Bayesian approach takes a different perspective on probability assumptions. It assumes that the unknown parameters are drawn from a prior distribution that represents our beliefs or knowledge about them before observing the data. We denote this prior distribution as $\pi(\theta)$. The term "prior" is crucial because the modeler should define this distribution before seeing the observed data.

For example, consider our model for the time to deliver food in @eq-log-linear. A reasonable prior for the regression parameter associated with distance would have a distribution that assigns zero probability to negative values, since we would never expect (log) delivery times to decrease with distance. If we worked at the restaurant, we could be more specific based on our experience. We might believe that, all other factors being equal, each additional mile from the restaurant doubles the delivery time. Using this assumption, we could define a probability distribution that reflects this belief.

Once we have our prior distributions for our parameters and assumptions regarding our data distributions, we can write down the equations required to estimate our results. Bayes' Rule is a basic probability statement that combines the prior distribution with our likelihood function: 

$$
\pi(\theta|x) = \frac{\pi(\theta) \ell(x|\theta)} {\pi(x)}
$$ {#eq-bayes-rule-distr}

$\pi(\theta|x)$ is the posterior distribution: the probability distribution of our parameters, given the observed data. This is the endpoint for any Bayesian analysis. 

Another important point is that Bayesian estimation has a much more difficult goal than maximum likelihood estimation.  The latter needs to find point estimates of its parameters while Bayesian estimation has to estimate the entire posterior distribution $\pi(\theta|x)$. In a moment, we’ll look at a simple problem with a simple solution. However, in most other cases, the computational requirements for Bayesian estimation are considerably higher. That's the bad news.

The good news is that, once we find the posterior distribution, it is incredibly useful. First, we can make direct statements about parameter values. Unlike confidence intervals, Bayesian methods allow us to say things like 

> "We believe that there is a 90% probability that the true value of the parameter is between $L$ and $U$." 

It also lets us easily make similar statements regarding more complex combinations of parameters (such as ratios, etc).

Finally, we should mention the effect of the prior on the computations. It does pull the likelihood $\ell(x|\theta)$ towards it. For example, suppose that for @eq-log-linear we used a highly restrictive prior for $\beta_1$ that was a uniform distribution between [0.7, 0.9]. In that case, the posterior would be confined to this range^[We’ll see how the prior can affect some calculations later in @sec-naive-bayes. ]. That said, the effect of the prior on the posterior _decreases_ as our training set size _increases_. We saw this in @sec-effect-encodings where two travel agents were contrasted; one with many reservations in the data and another with very few. 

To illustrate, let’s look at a very simple example. 

### A Single Proportion  {#sec-single-proportion}

```{r}
#| label: include-forested
#| include: false
load("../RData/forested_data.RData")

beta_bin_estimate <- function(num_events, total, alpha = 1, beta = 1) {
  (num_events + alpha) / (alpha + beta + total) * 100
}

alpha <- 5
beta <- 3

n_y_small <- 2
n_tr_small <- 3

n_y <- sum(forested_train$class == "Yes")
n_tr <- nrow(forested_train)
p_mle <- mean(forested_train$class == "Yes") * 100

alpha_post <- alpha + n_y
beta_post <- n_tr - n_y + beta
```

For the forestry data discussed earlier in @sec-spatial-resampling, the outcome is categorical, with the values "yes" and "no" representing the question "Is this location forested?" We can use the training dataset to estimate the probability ($\pi$) of the event occurring. The simplest estimate is the sample proportion, which is calculated by dividing the number of occurrences of the event (e.g., "yes" responses) by the total number of data points. This gives the estimate $\hat{\pi}$ = `r round(p_mle, 3)`%). 

To estimate this rate using maximum likelihood estimation, we might assume that the data follow a binomial distribution with theoretical probability $\pi$. From there we can solve equations that find a value of $\pi$ that correspond to the largest likelihood. It turns out that the sample proportion is also the maximum likelihood estimate. 

Instead of treating the unknown parameter as a single value, Bayesian methods propose that the parameter comes from a _distribution_ of possible values. This distribution reflects our prior understanding or belief about the parameter based on what we know of the situation. For this reason, it is called a _prior_ distribution. If we think that locations in Washington state are very likely to be forested, we would choose a distribution that has more area for higher probabilities. 

For a binomial model, an example of a prior is the Beta distribution. The Beta distribution is very flexable and has values range between zero and one. It is indexed by two parameters: $\alpha$ and $\beta$. @fig-beta-dist shows different versions of the Beta distribution for different values.  

To settle on a specific prior, we would posit different questions such as:

- "Are there rate values that we would _never_ believe possible?"
- "What is the most likely value that we would expect and how certain are we of that?" 
- "Do we think that the distribution of possible values is symmetric?"

and so on.

From these answers, we would experiment with different values of $\alpha$ and $\beta$ until we find a combination that encapsulates what we believe. If we think that larger probabilities of forestation are more likely, we might choose a Beta prior that has values of $\alpha$ that are larger than $\beta$, which places more mass on larger values (as seen below). This is an example of an _informative prior_, albeit a weak one. As our prior distribution is more peaked it reflects that, before seeing any data, we have strong beliefs. If we honestly have no idea, we could choose a uniform distribution between zero and one using $\alpha = \beta = 1$.  

```{r}
#| label: fig-beta-dist
#| echo: false
#| out-width: 70%
#| fig-width: 6
#| fig-height: 3
#| fig-cap: Examples of the Beta distribution for different values of $\alpha$ and $\beta$.

crossing(
  value = seq(0, 1, length.out = 100),
  alpha = c(1, 3, 5),
  beta = c(1, 3, 5)
) %>% 
  mutate(
    density = dbeta(value, alpha, beta),
    alpha = format(alpha)) %>% 
  ggplot(aes(value, density, col = alpha)) + 
  geom_line() +
  facet_wrap(~beta, labeller = label_both) +
  labs(x = "Probability of Forestation") +
  scale_colour_viridis_d(option = "viridis")
```

We'll use values of $\alpha = 5$ and $\beta = 3$. If the training set has $n_{tr}$ points and $n_+$ of them are known to be forested, the ordinary sample proportion estimate is $\hat{p} = n_+ / n_{tr}$. In a Bayesian analysis, the final estimate is a function of both the prior distribution and our observed data. For a Beta prior, the Bayesian estimate is 

$$
\hat{p}_{BB} = \frac{n_+ +\alpha}{n_{tr} + \alpha + \beta}
$$ {#eq-beta-bin-mean}

If, before seeing the data, we had chosen $\alpha = 5$ and $\beta = 1$, we estimate that $\hat{p}_{BB} = `r round(beta_bin_estimate(n_y, n_tr, 5, 1), 3)`$%. This is pretty close to our simple estimate because there is so much data in the training set ($n_{tr}$ = `r format(n_tr, big.mark = ",")`) that the influence of the prior is severely diminished. As a counter-example, suppose we took a very small sample that resulted in $n_y$ = 1 and $n_{tr}$ = 3, the prior would pull the estimate from the MLE of 33.3% to `r round(beta_bin_estimate(1, 3, 5, 3), 1)`%. 

Now suppose that for regulatory purposes, we were required to produce an interval estimate for our parameter. From these data and our prior, we could say that the true probability of forestation has a 90% chance of being between `r round(qbeta(0.05, alpha_post, beta_post)*100, 1)`% and `r round(qbeta(0.95, alpha_post, beta_post)*100, 1)`%. 

We did mention that it can be very difficult to compute the posterior distribution. We deliberately chose the Beta distribution because, if we assume a binomial distribution for our data and a $Beta(\alpha, \beta)$ prior, the posterior is  $Beta(\alpha + n_y, n_{tr} - n_y + \beta)$. More often than not, we will not have a simple analytical solution for the posterior. That said, we’ll see this happen again in @sec-gp.

For a Bayesian model, the predictions also have a posterior _distribution_, reflecting the probability of a wide range of values. As with non-Bayesian models, we often summarize the posterior using the most likely value (perhaps using the mean or mode of the distribution). We can also measure the uncertainty in the prediction using the estimated standard deviation. 

::: {.note-box}
To summarize: 

 - Bayesian models require a prior distribution for all of our model parameters. 
 - The prior and observed data are combined into a posterior distribution.
 - Different statistics can be estimated from the posterior, including individual predictions.  
:::

We’ll encounter even more Bayesian methods in subsequent chapters. In @sec-cls-metrics, we'll describe the process of developing a prior for muticlass problem based on Wordle scores.

Now that we know more about Bayesian statistics, let's see how they can be used to tune models.

## Chapter References {.unnumbered}
